# üéµ music-chore

# Disclaimer
This is an experimental project intended to explore AI agents. 
The code was fully generated by an automated system and may contain errors. 
The product is provided as is, without warranties of any kind. Use at your own risk.

--- 

<div align="center">

**A precision CLI tool for organizing and normalizing local music libraries**

[![Rust](https://img.shields.io/badge/rust-2024-blue.svg)](https://www.rust-lang.org)
[![macOS](https://img.shields.io/badge/platform-macOS-lightgrey.svg)](https://www.apple.com/macos/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

*Built for AI agents, perfect for humans*

</div>

---

## üéØ Overview

**music-chore** is a lightweight, blazing-fast CLI tool that brings order to chaotic music libraries. It works entirely offline‚Äîreading and normalizing metadata from your existing files and directory structure. No internet lookups, no external services, just pure local processing.

### ‚ú® What It Does

- üîç **Recursively scans** music directories to discover albums and tracks
- üè∑Ô∏è **Extracts metadata** from FLAC files using actual file parsing
- üìÇ **Infers structure** from your folder organization (Artist ‚Üí Album ‚Üí Tracks)
- üî§ **Normalizes text** (title case, consistent formatting)
- üå≥ **Displays beautiful tree views** of your library hierarchy
- üìä **Outputs structured data** perfect for AI agents via MCP

### üéµ Supported Formats

- **v1**: `.flac` files
- **Future**: `.mp3`, `.wav`, `.dsf`

---

## üöÄ Quick Start

### Installation

```bash
# Build from source
cargo install --path .

# Or build and run locally
cargo build --release
```

### Basic Usage

```bash
# Scan your music directory
musicctl scan /path/to/music

# Show beautiful tree view
musicctl tree /path/to/music

# Read metadata from a specific file
musicctl read /path/to/track.flac

# Normalize track titles (dry run first)
musicctl normalize /path/to/music --dry-run
```

---

## üìñ Commands

### üîç `scan` - Discover Music Files

```bash
musicctl scan /path/to/music
```

Outputs a compact, parseable list of discovered music files:

```
/music/Artist/Album/track01.flac
/music/Artist/Album/track02.flac
```

### üå≥ `tree` - Visualize Library Structure

```bash
musicctl tree /path/to/music
```

Beautiful hierarchical view of your music library:

```
üìÅ Music Folder
‚îú‚îÄ‚îÄ üìÇ Tracks
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track1.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track2.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track3.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track4.flac [ü§ñ] FLAC
```

### üìñ `read` - Extract Metadata

```bash
musicctl read /Music/Tracks/Track1.flac
```

Detailed metadata extraction:

```
{
  "file_path": "/Music/Tracks/Track1.flac",
  "metadata": {
    "title": {
      "value": "Track1",
      "source": "Embedded",
      "confidence": 1.0
    },
    "artist": {
      "value": "Super Artist",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album": {
      "value": "Something",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album_artist": {
      "value": "Album First",
      "source": "Embedded",
      "confidence": 1.0
    },
    "track_number": {
      "value": 9,
      "source": "Embedded",
      "confidence": 1.0
    },
    "disc_number": {
      "value": 1,
      "source": "Embedded",
      "confidence": 1.0
    },
    "year": {
      "value": 2025,
      "source": "Embedded",
      "confidence": 1.0
    },
    "genre": {
      "value": "New Age",
      "source": "Embedded",
      "confidence": 1.0
    },
    "duration": {
      "value": 205.871,
      "source": "Embedded",
      "confidence": 1.0
    },
    "format": "flac",
    "path": "/Music/Tracks/Track1.flac"
  }
}
```

### üî§ `normalize` - Fix Track Titles

```bash
# Preview changes
musicctl normalize /path/to/music --dry-run

# Apply changes
musicctl normalize /path/to/music
```

Transforms messy titles into clean title case:
- `"come together"` ‚Üí `"Come Together"`
- `"SOMETHING"` ‚Üí `"Something"`
- `"here comes the sun"` ‚Üí `"Here Comes The Sun"`

---

## üèóÔ∏è Architecture

music-chore follows **Unix philosophy principles**: small, sharp, composable tools.

```
src/
‚îú‚îÄ‚îÄ domain/                 # Pure business logic (no external deps)
‚îÇ   ‚îú‚îÄ‚îÄ models.rs           # Artist, Album, Track, Metadata
‚îÇ   ‚îú‚îÄ‚îÄ traits.rs           # AudioFile trait for extensibility
‚îÇ   ‚îî‚îÄ‚îÄ library.rs          # Library hierarchy building
‚îú‚îÄ‚îÄ infrastructure/         # External concerns
‚îÇ   ‚îú‚îÄ‚îÄ scanner.rs          # Format-agnostic directory scanning
‚îÇ   ‚îî‚îÄ‚îÄ formats/            # Audio format implementations
‚îî‚îÄ‚îÄ services/               # Business services
    ‚îú‚îÄ‚îÄ inference.rs        # Path-based metadata inference
    ‚îî‚îÄ‚îÄ normalization.rs    # Text normalization
```

### üéõÔ∏è Extensible Design

Adding new audio formats is simple:

```rust
impl AudioFile for Mp3Handler {
    fn can_handle(&self, path: &Path) -> bool {
        path.extension().map_or(false, |ext| ext == "mp3")
    }
    
    fn read_metadata(&self, path: &Path) -> Result<Track, AudioFileError> {
        // MP3-specific implementation
    }
}
```

---

## ü§ñ AI Agent Integration

Designed from the ground up for **MCP (Model Context Protocol)** usage:

- **Structured output**: Commands return parseable, machine-readable results
- **Composable operations**: Each command does one thing perfectly
- **Predictable behavior**: Same input always produces same output
- **Error handling**: Clear, structured error messages
- **Incremental processing**: Add new folders without full rescans

### Example Agent Workflow

```bash
# Discover what's new
musicctl scan ~/Music --since yesterday

# Get library overview  
musicctl tree ~/Music --format json

# Extract specific metadata
musicctl read ~/Music/Artist/Album/track.flac --output json

# Normalize new additions
musicctl normalize ~/Music --dry-run
```

---

## üéØ Design Principles

1. **Local Only** - No internet access, no external services
2. **Format Agnostic** - Clean trait system for easy format extension  
3. **Deterministic** - Same input always produces same output
4. **CLI Native** - Designed for shell pipelines and automation
5. **AI Friendly** - Machine-readable output for agent usage
6. **Unix Philosophy** - Do one thing and do it exceptionally well

---

## üß™ Testing

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_normalize_track_titles
```

## ü§ù Contributing

1. **Fork** the repository
2. **Create** a feature branch: `git checkout -b feature/amazing-feature`
3. **Commit** your changes: `git commit -m 'Add amazing feature'`
4. **Push** to the branch: `git push origin feature/amazing-feature`
5. **Open** a Pull Request

### Development Guidelines

- Follow existing code patterns and conventions
- Add tests for all new functionality
- Keep modules small and focused
- Prefer clarity to cleverness
- All public functions must be tested

---

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

<div align="center">

**Built by AI Agent with ‚ù§Ô∏è for music lovers and AI agents**

*If you find this useful, give it a ‚≠ê on GitHub!*

</div>