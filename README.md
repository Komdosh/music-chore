# üéµ music-chore

# Disclaimer
This is an experimental project intended to explore AI agents. 
The code was fully generated by an automated system and may contain errors. 
The product is provided as is, without warranties of any kind. Use at your own risk.

--- 

<div align="center">

**A precision CLI tool for organizing and normalizing local music libraries**

[![Rust](https://img.shields.io/badge/rust-2024-blue.svg)](https://www.rust-lang.org)
[![macOS](https://img.shields.io/badge/platform-macOS-lightgrey.svg)](https://www.apple.com/macos/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

*Built for AI agents, perfect for humans*

</div>

---

## üéØ Overview

**music-chore** is a lightweight, blazing-fast CLI tool that brings order to chaotic music libraries. It works entirely offline‚Äîreading and normalizing metadata from your existing files and directory structure. No internet lookups, no external services, just pure local processing.

### ‚ú® What It Does

- üîç **Recursively scans** music directories to discover albums and tracks
- üè∑Ô∏è **Extracts metadata** from FLAC files using actual file parsing
- üìÇ **Infers structure** from your folder organization (Artist ‚Üí Album ‚Üí Tracks)
- üî§ **Normalizes text** (title case, consistent formatting)
- üå≥ **Displays beautiful tree views** of your library hierarchy
- üìä **Outputs structured data** perfect for AI agents via MCP

### üéµ Supported Formats

- **v1**: `.flac` files
- **Future**: `.mp3`, `.wav`, `.dsf`

---

## üöÄ Quick Start

### Installation

Simplest way:

```bash
curl -fsSL https://github.com/Komdosh/music-chore/releases/latest/download/install.sh | bash
```

From sources:

```bash
# Build from source
cargo install --path .

# Or build and run locally
cargo build --release
```

### Basic Usage

```bash
# Scan your music directory
musicctl scan /path/to/music

# Show beautiful tree view
musicctl tree /path/to/music

# Read metadata from a specific file
musicctl read /path/to/track.flac

# Emit structured metadata (JSON or AI-friendly format)
musicctl emit /path/to/music --json

# Normalize track titles (dry run first)
musicctl normalize /path/to/music --dry-run
```

---

## üìñ Commands

### üîç `scan` - Discover Music Files

```bash
musicctl scan /path/to/music
```

Outputs a compact, parseable list of discovered music files:

```
/music/Artist/Album/track01.flac
/music/Artist/Album/track02.flac
```

### üå≥ `tree` - Visualize Library Structure

```bash
musicctl tree /path/to/music
```

Beautiful hierarchical view of your music library:

```
üìÅ Music Folder
‚îú‚îÄ‚îÄ üìÇ Tracks
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track1.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track2.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track3.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track4.flac [ü§ñ] FLAC
```

### üìñ `read` - Extract Metadata

```bash
musicctl read /Music/Tracks/Track1.flac
```

Detailed metadata extraction:

```
{
  "file_path": "/Music/Tracks/Track1.flac",
  "metadata": {
    "title": {
      "value": "Track1",
      "source": "Embedded",
      "confidence": 1.0
    },
    "artist": {
      "value": "Super Artist",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album": {
      "value": "Something",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album_artist": {
      "value": "Album First",
      "source": "Embedded",
      "confidence": 1.0
    },
    "track_number": {
      "value": 9,
      "source": "Embedded",
      "confidence": 1.0
    },
    "disc_number": {
      "value": 1,
      "source": "Embedded",
      "confidence": 1.0
    },
    "year": {
      "value": 2025,
      "source": "Embedded",
      "confidence": 1.0
    },
    "genre": {
      "value": "New Age",
      "source": "Embedded",
      "confidence": 1.0
    },
    "duration": {
      "value": 205.871,
      "source": "Embedded",
      "confidence": 1.0
    },
    "format": "flac",
    "path": "/Music/Tracks/Track1.flac"
  }
}
```

### üî§ `normalize` - Fix Track Titles

```bash
# Preview changes
musicctl normalize /path/to/music --dry-run

# Apply changes
musicctl normalize /path/to/music
```

Transforms messy titles into clean title case:
- `"come together"` ‚Üí `"Come Together"`
- `"SOMETHING"` ‚Üí `"Something"`
- `"here comes the sun"` ‚Üí `"Here Comes The Sun"`

### üì§ `emit` - Export Structured Metadata

```bash
# AI-friendly structured text (default)
musicctl emit /path/to/music

# JSON format for programmatic use
musicctl emit /path/to/music --json
```

**Structured Text Output** (AI-optimized):
```
=== MUSIC LIBRARY METADATA ===
Total Artists: 1
Total Albums: 1
Total Tracks: 2

ARTIST: The Beatles
  ALBUM: Abbey Road (1969)
    TRACK: "Come Together" | Duration: 4:19 | File: /music/The Beatles/Abbey Road/01 - Come Together.flac
    TRACK: "Something" | Duration: 3:03 | File: /music/The Beatles/Abbey Road/02 - Something.flac

=== END METADATA ===
```

**JSON Output** (programmatic):
```json
{
  "artists": [
    {
      "name": "The Beatles",
      "albums": [
        {
          "title": "Abbey Road",
          "year": 1969,
          "tracks": [
            {
              "file_path": "/music/The Beatles/Abbey Road/01 - Come Together.flac",
              "metadata": {
                "title": { "value": "Come Together", "source": "Embedded", "confidence": 1.0 },
                "artist": { "value": "The Beatles", "source": "Embedded", "confidence": 1.0 },
                "album": { "value": "Abbey Road", "source": "Embedded", "confidence": 1.0 },
                "duration": { "value": 259.0, "source": "Embedded", "confidence": 1.0 }
              }
            }
          ]
        }
      ]
    }
  ],
  "total_tracks": 2,
  "total_artists": 1,
  "total_albums": 1
}
```

---

## üèóÔ∏è Architecture

music-chore follows **Unix philosophy principles**: small, sharp, composable tools.

```
src/
‚îú‚îÄ‚îÄ domain/                 # Pure business logic (no external deps)
‚îÇ   ‚îú‚îÄ‚îÄ models.rs           # Artist, Album, Track, Metadata
‚îÇ   ‚îú‚îÄ‚îÄ traits.rs           # AudioFile trait for extensibility
‚îÇ   ‚îî‚îÄ‚îÄ library.rs          # Library hierarchy building
‚îú‚îÄ‚îÄ infrastructure/         # External concerns
‚îÇ   ‚îú‚îÄ‚îÄ scanner.rs          # Format-agnostic directory scanning
‚îÇ   ‚îî‚îÄ‚îÄ formats/            # Audio format implementations
‚îî‚îÄ‚îÄ services/               # Business services
    ‚îú‚îÄ‚îÄ inference.rs        # Path-based metadata inference
    ‚îî‚îÄ‚îÄ normalization.rs    # Text normalization
```

### üéõÔ∏è Extensible Design

Adding new audio formats is simple:

```rust
impl AudioFile for Mp3Handler {
    fn can_handle(&self, path: &Path) -> bool {
        path.extension().map_or(false, |ext| ext == "mp3")
    }
    
    fn read_metadata(&self, path: &Path) -> Result<Track, AudioFileError> {
        // MP3-specific implementation
    }
}
```

---

## ü§ñ AI Agent Integration

### MCP Server

music-chore includes a **Model Context Protocol (MCP) server** for seamless AI agent integration:

```bash
# Start MCP server
musicctl-mcp --verbose

# Configure in Claude Desktop
{
  "mcpServers": {
    "music-chore": {
      "command": "/path/to/musicctl-mcp",
      "args": ["--verbose"]
    }
  }
}
```

**Available MCP Tools:**
- `scan_directory` - Scan directories for music files
- `get_library_tree` - Get hierarchical library view  
- `read_file_metadata` - Read metadata from individual files
- `normalize_titles` - Normalize track titles
- `emit_library_metadata` - Get complete structured library data

### AI-Friendly Features

- **Structured output**: Commands return parseable, machine-readable results
- **Composable operations**: Each command does one thing perfectly
- **Predictable behavior**: Same input always produces same output
- **Error handling**: Clear, structured error messages
- **Incremental processing**: Add new folders without full rescans

### Example Agent Workflow

```bash
# Discover what's new
musicctl scan ~/Music --since yesterday

# Get library overview  
musicctl tree ~/Music --json

# Export metadata for AI processing
musicctl emit ~/Music --json

# Extract specific metadata
musicctl read ~/Music/Artist/Album/track.flac

# Normalize new additions
musicctl normalize ~/Music --dry-run
```

üìñ **Detailed MCP Documentation**: 
- [MCP Server Guide](docs/MCP_SERVER.md) - Complete server setup and usage
- [MCP Configuration Examples](docs/MCP_CONFIG_EXAMPLES.md) - Client integration examples

---

## üéØ Design Principles

1. **Local Only** - No internet access, no external services
2. **Format Agnostic** - Clean trait system for easy format extension  
3. **Deterministic** - Same input always produces same output
4. **CLI Native** - Designed for shell pipelines and automation
5. **AI Friendly** - Machine-readable output for agent usage
6. **Unix Philosophy** - Do one thing and do it exceptionally well

---

## üß™ Testing

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_emit_command
```

## ü§ù Contributing

1. **Fork** the repository
2. **Create** a feature branch: `git checkout -b feature/amazing-feature`
3. **Commit** your changes: `git commit -m 'Add amazing feature'`
4. **Push** to the branch: `git push origin feature/amazing-feature`
5. **Open** a Pull Request

### Development Guidelines

- Follow existing code patterns and conventions
- Add tests for all new functionality
- Keep modules small and focused
- Prefer clarity to cleverness
- All public functions must be tested

---

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

<div align="center">

**Built by AI Agent with ‚ù§Ô∏è for music lovers and AI agents**

*If you find this useful, give it a ‚≠ê on GitHub!*

</div>