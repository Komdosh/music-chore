# üéµ music-chore

# Disclaimer
This is an experimental project intended to explore AI agents. 
The code was fully generated by an automated system and may contain errors. 
The product is provided as is, without warranties of any kind. Use at your own risk.

--- 

<div align="center">

**A precision CLI tool for organizing and normalizing local music libraries**

[![Rust](https://img.shields.io/badge/rust-2024-blue.svg)](https://www.rust-lang.org)
[![macOS](https://img.shields.io/badge/platform-macOS-lightgrey.svg)](https://www.apple.com/macos/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

*Built for AI agents, perfect for humans*

</div>

---

## üéØ Overview

**music-chore** is a lightweight, blazing-fast CLI tool that brings order to chaotic music libraries. It works entirely offline‚Äîreading and normalizing metadata from your existing files and directory structure. No internet lookups, no external services, just pure local processing.

### ‚ú® What It Does

- üîç **Recursively scans** music directories to discover albums and tracks
- üè∑Ô∏è **Extracts metadata** from FLAC files using actual file parsing
- üìÇ **Infers structure** from your folder organization (Artist ‚Üí Album ‚Üí Tracks)
- üî§ **Normalizes text** (title case, consistent formatting)
- üå≥ **Displays beautiful tree views** of your library hierarchy
- üìä **Outputs structured data** perfect for AI agents via MCP

### üéµ Supported Formats

- **v1**: `.flac` files
- **Future**: `.mp3`, `.wav`, `.dsf`

---

## üöÄ Quick Start

### üì¶Installation

```bash
curl -fsSL https://github.com/Komdosh/music-chore/releases/latest/download/install.sh | bash
```

From sources:

```bash
# Build from source
cargo install --path .

# Or build and run locally
cargo build --release
```

### ü§ñ MCP Server Setup

**Install CLI MCP locally:**

```bash
curl -fsSL https://github.com/Komdosh/music-chore/releases/latest/download/install_mcp.sh | bash
```

**Then you can install it for agents:**

- **Claude:**

```bash
claude mcp add music-chore -- musicctl-mcp
```

- **Opencode:**

```json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "music-chore": {
      "type": "local",
      "command": ["musicctl-mcp"]
    }
  }
}
```

### üîß Basic CLI Usage

```bash
# Scan your music directory
musicctl scan /path/to/music

# Show beautiful tree view
musicctl tree /path/to/music

# Read metadata from a specific file
musicctl read /path/to/track.flac

# Emit structured metadata (JSON or AI-friendly format)
musicctl emit /path/to/music --json

# Normalize track titles (dry run first)
musicctl normalize /path/to/music --dry-run
```

---

## üìñ Commands

### üîç `scan` - Discover Music Files

```bash
musicctl scan /path/to/music
```

Outputs a compact, parseable list of discovered music files:

```
/music/Artist/Album/track01.flac
/music/Artist/Album/track02.flac
```

### üå≥ `tree` - Visualize Library Structure

```bash
musicctl tree /path/to/music
```

Beautiful hierarchical view of your music library:

```
üìÅ Music Folder
‚îú‚îÄ‚îÄ üìÇ Tracks
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track1.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track2.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track3.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track4.flac [ü§ñ] FLAC
```

### üìñ `read` - Extract Metadata

```bash
musicctl read /Music/Tracks/Track1.flac
```

Detailed metadata extraction:

```
{
  "file_path": "/Music/Tracks/Track1.flac",
  "metadata": {
    "title": {
      "value": "Track1",
      "source": "Embedded",
      "confidence": 1.0
    },
    "artist": {
      "value": "Super Artist",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album": {
      "value": "Something",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album_artist": {
      "value": "Album First",
      "source": "Embedded",
      "confidence": 1.0
    },
    "track_number": {
      "value": 9,
      "source": "Embedded",
      "confidence": 1.0
    },
    "disc_number": {
      "value": 1,
      "source": "Embedded",
      "confidence": 1.0
    },
    "year": {
      "value": 2025,
      "source": "Embedded",
      "confidence": 1.0
    },
    "genre": {
      "value": "New Age",
      "source": "Embedded",
      "confidence": 1.0
    },
    "duration": {
      "value": 205.871,
      "source": "Embedded",
      "confidence": 1.0
    },
    "format": "flac",
    "path": "/Music/Tracks/Track1.flac"
  }
}
```

### üî§ `normalize` - Fix Track Titles

```bash
# Preview changes
musicctl normalize /path/to/music --dry-run

# Apply changes
musicctl normalize /path/to/music
```

Transforms messy titles into clean title case:
- `"come together"` ‚Üí `"Come Together"`
- `"SOMETHING"` ‚Üí `"Something"`
- `"here comes the sun"` ‚Üí `"Here Comes The Sun"`

### ‚úèÔ∏è `write` - Update Metadata

```bash
# Preview metadata changes
musicctl write /path/to/track.flac --dry-run --set "title=New Title" --set "artist=New Artist"

# Apply metadata changes
musicctl write /path/to/track.flac --apply --set "title=New Title" --set "artist=New Artist"
```

Update embedded metadata in FLAC files:

**Supported Metadata Fields:**
- `title` - Track title
- `artist` - Track artist
- `album` - Album name
- `albumartist` - Album artist
- `tracknumber` - Track number (1-99)
- `discnumber` - Disc number (1-99)
- `year` - Release year (1000-9999)
- `genre` - Genre name

**Examples:**
```bash
# Single field update
musicctl write track.flac --apply --set "title=Come Together"

# Multiple field updates
musicctl write track.flac --apply --set "title=Come Together" --set "artist=The Beatles" --set "tracknumber=1"

# Dry run to preview changes
musicctl write track.flac --dry-run --set "year=1969"
```

### üì§ `emit` - Export Structured Metadata

```bash
# AI-friendly structured text (default)
musicctl emit /path/to/music

# JSON format for programmatic use
musicctl emit /path/to/music --json
```

**Structured Text Output** (AI-optimized):
```
=== MUSIC LIBRARY METADATA ===
Total Artists: 1
Total Albums: 1
Total Tracks: 2

ARTIST: The Beatles
  ALBUM: Abbey Road (1969)
    TRACK: "Come Together" | Duration: 4:19 | File: /music/The Beatles/Abbey Road/01 - Come Together.flac
    TRACK: "Something" | Duration: 3:03 | File: /music/The Beatles/Abbey Road/02 - Something.flac

=== END METADATA ===
```

**JSON Output** (programmatic):
```json
{
  "artists": [
    {
      "name": "The Beatles",
      "albums": [
        {
          "title": "Abbey Road",
          "year": 1969,
          "tracks": [
            {
              "file_path": "/music/The Beatles/Abbey Road/01 - Come Together.flac",
              "metadata": {
                "title": { "value": "Come Together", "source": "Embedded", "confidence": 1.0 },
                "artist": { "value": "The Beatles", "source": "Embedded", "confidence": 1.0 },
                "album": { "value": "Abbey Road", "source": "Embedded", "confidence": 1.0 },
                "duration": { "value": 259.0, "source": "Embedded", "confidence": 1.0 }
              }
            }
          ]
        }
      ]
    }
  ],
  "total_tracks": 2,
  "total_artists": 1,
  "total_albums": 1
}
```

---

## üèóÔ∏è Architecture

music-chore follows **Unix philosophy principles**: small, sharp, composable tools.

```
src/
‚îú‚îÄ‚îÄ domain/                 # Pure business logic (no external deps)
‚îÇ   ‚îú‚îÄ‚îÄ models.rs           # Artist, Album, Track, Metadata
‚îÇ   ‚îú‚îÄ‚îÄ traits.rs           # AudioFile trait for extensibility
‚îÇ   ‚îî‚îÄ‚îÄ library.rs          # Library hierarchy building
‚îú‚îÄ‚îÄ infrastructure/         # External concerns
‚îÇ   ‚îú‚îÄ‚îÄ scanner.rs          # Format-agnostic directory scanning
‚îÇ   ‚îî‚îÄ‚îÄ formats/            # Audio format implementations
‚îî‚îÄ‚îÄ services/               # Business services
    ‚îú‚îÄ‚îÄ inference.rs        # Path-based metadata inference
    ‚îî‚îÄ‚îÄ normalization.rs    # Text normalization
```

### üéõÔ∏è Extensible Design

Adding new audio formats is simple:

```rust
impl AudioFile for Mp3Handler {
    fn can_handle(&self, path: &Path) -> bool {
        path.extension().map_or(false, |ext| ext == "mp3")
    }
    
    fn read_metadata(&self, path: &Path) -> Result<Track, AudioFileError> {
        // MP3-specific implementation
    }
}
```

---

## ü§ñ AI Agent Integration

### MCP Server (‚úÖ Complete)

music-chore includes a **fully functional Model Context Protocol (MCP) server** for seamless AI agent integration:

```bash
# Build and start MCP server
cargo install --path .
musicctl-mcp --verbose

# Test MCP server
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | musicctl-mcp
```

### üõ†Ô∏è Available MCP Tools

| Tool | Description | Parameters | Use Case |
|-------|-------------|------------|----------|
| `scan_directory` | Scan directories for music files | `path` (required), `json_output` (optional) | "Discover what music files I have" |
| `get_library_tree` | Get hierarchical library view | `path` (required), `json_output` (optional) | "Show me my library structure" |
| `read_file_metadata` | Read metadata from individual files | `file_path` (required) | "Extract full metadata from this track" |
| `normalize_titles` | Normalize track titles to title case | `path` (required), `dry_run` (optional) | "Fix messy capitalization in my tracks" |
| `emit_library_metadata` | Get complete structured library data | `path` (required), `format` (optional) | "Export my library for analysis" |

### üß™ Example AI Workflows

**Library Analysis:**
```
User: "Analyze my music library and tell me about my collection"
Claude: [Calls scan_directory ‚Üí get_library_tree ‚Üí emit_library_metadata]
"I found 15 artists across 42 albums with 380 total tracks. 
Your collection spans from 1968-2024 with genres including rock, jazz, and classical."
```

**Metadata Extraction:**
```
User: "What's the metadata for this Beatles track?"  
Claude: [Calls read_file_metadata]
"This FLAC file contains:
- Title: 'Come Together' (embedded, 100% confidence)
- Artist: 'The Beatles' (embedded, 100% confidence)  
- Album: 'Abbey Road' (embedded, 100% confidence)
- Duration: 4:19 (259 seconds)
- Format: FLAC, 16-bit/44.1kHz"
```

**Batch Operations:**
```
User: "I just added 50 new tracks. Can you organize their titles?"
Claude: [Calls normalize_titles with dry_run=true ‚Üí normalize_titles with dry_run=false]
"Preview: 12 tracks need title corrections. Apply changes? [Yes/No]"
‚úÖ "Normalized 12 track titles: 'yesterday' ‚Üí 'Yesterday', 'come together' ‚Üí 'Come Together', etc."
```

### ‚úÖ Verify MCP Server Installation

Test that your MCP server is working:

```bash
cat <<EOF | musicctl-mcp | jq
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"bash","version":"0.1"}}}
{"jsonrpc":"2.0","method":"notifications/initialized"}
EOF
```

### AI-Friendly Features

- **Structured output**: Commands return parseable, machine-readable results
- **Composable operations**: Each command does one thing perfectly
- **Predictable behavior**: Same input always produces same output
- **Error handling**: Clear, structured error messages
- **Incremental processing**: Add new folders without full rescans

### Example Agent Workflow

```bash
# Discover what's new
musicctl scan ~/Music --since yesterday

# Get library overview  
musicctl tree ~/Music --json

# Export metadata for AI processing
musicctl emit ~/Music --json

# Extract specific metadata
musicctl read ~/Music/Artist/Album/track.flac

# Normalize new additions
musicctl normalize ~/Music --dry-run

# Update track metadata
musicctl write ~/Music/Artist/Album/track.flac --dry-run --set "title=New Title"
```

üìñ **Detailed MCP Documentation**: 
- [MCP Server Guide](docs/MCP_SERVER.md) - Complete server setup and usage
- [MCP Configuration Examples](docs/MCP_CONFIG_EXAMPLES.md) - Client integration examples

---

## üéØ Design Principles

1. **Local Only** - No internet access, no external services
2. **Format Agnostic** - Clean trait system for easy format extension  
3. **Deterministic** - Same input always produces same output
4. **CLI Native** - Designed for shell pipelines and automation
5. **AI Friendly** - Machine-readable output for agent usage
6. **Unix Philosophy** - Do one thing and do it exceptionally well

---

## üß™ Testing

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_emit_command
```

## ü§ù Contributing

1. **Fork** the repository
2. **Create** a feature branch: `git checkout -b feature/amazing-feature`
3. **Commit** your changes: `git commit -m 'Add amazing feature'`
4. **Push** to the branch: `git push origin feature/amazing-feature`
5. **Open** a Pull Request

### Development Guidelines

- Follow existing code patterns and conventions
- Add tests for all new functionality
- Keep modules small and focused
- Prefer clarity to cleverness
- All public functions must be tested

---

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

<div align="center">

**Built by AI Agent with ‚ù§Ô∏è for music lovers and AI agents**

*If you find this useful, give it a ‚≠ê on GitHub!*

</div>
