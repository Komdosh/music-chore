# üéµ music-chore

# Disclaimer
This is an experimental project intended to explore AI agents. 
The code was fully generated by an automated system and may contain errors. 
The product is provided as is, without warranties of any kind. Use at your own risk.

--- 

<div align="center">

**A precision CLI tool for organizing and normalizing local music libraries**

[![Rust](https://img.shields.io/badge/rust-2024-blue.svg)](https://www.rust-lang.org)
[![macOS](https://img.shields.io/badge/platform-macOS-lightgrey.svg)](https://www.apple.com/macos)
[![linux](https://img.shields.io/badge/platform-linux-lightgrey.svg)](https://www.linux.org)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

*Built for AI agents, perfect for humans*

</div>

---

## üéØ Overview

**music-chore** is a lightweight, blazing-fast CLI tool that brings order to chaotic music libraries. It works entirely offline‚Äîreading and normalizing metadata from your existing files and directory structure. No internet lookups, no external services, just pure local processing.

### ‚ú® What It Does

- üîç **Recursively scans** music directories to discover albums and tracks
- üè∑Ô∏è **Extracts metadata** from FLAC, MP3, and WAV files using actual file parsing
- üìÇ **Infers structure** from your folder organization (Artist ‚Üí Album ‚Üí Tracks)
- üî§ **Normalizes text** (title case, consistent formatting)
- üå≥ **Displays beautiful tree views** of your library hierarchy
- üîÑ **Detects duplicates** using SHA256 checksums across your entire library
- üìä **Outputs structured data** perfect for AI agents via MCP
- üìù **Generates and parses CUE files** for album disc images

### üéµ Supported Formats

- `.flac`, `.mp3`, and `.wav` files
- **Future**: `.dsf`

---

## üöÄ Quick Start

### üì¶Installation MacOS and Linux

```bash
curl -fsSL https://github.com/Komdosh/music-chore/releases/latest/download/install.sh | bash
```

From sources:

```bash
# Build from source
cargo install --path .

# Or build and run locally
cargo build --release
```

### ü§ñ MCP Server Setup MacOS and Linux

**Install CLI MCP locally:**

```bash
curl -fsSL https://github.com/Komdosh/music-chore/releases/latest/download/install_mcp.sh | bash
```

**Then you can install it for agents:**

- **Claude:**

```bash
claude mcp add music-chore -- musicctl-mcp
```

- **Opencode:**

```json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "music-chore": {
      "type": "local",
      "command": ["musicctl-mcp"]
    }
  }
}
```

### üîß Basic CLI Usage

```bash
# Scan your music directory (now supports both FLAC and MP3)
musicctl scan /path/to/music

# Show beautiful tree view with format indicators
musicctl tree /path/to/music

# Read metadata from a specific file (FLAC or MP3)
musicctl read /path/to/track.flac
musicctl read /path/to/track.mp3

# Emit structured metadata (JSON or AI-friendly format)
musicctl emit /path/to/music --json

# Normalize track titles (dry run first)
musicctl normalize /path/to/music --dry-run

# Find duplicate tracks by checksum
musicctl duplicates /path/to/music

# Generate CUE file for an album
musicctl cue /path/to/album --dry-run
musicctl cue /path/to/album --force

# Parse and display CUE file contents
musicctl cue-parse /path/to/album.cue
musicctl cue-parse /path/to/album.cue --json

# Validate CUE file against its audio files
musicctl cue-validate /path/to/album.cue
musicctl cue-validate /path/to/album.cue --audio-dir /path/to/audio --json
```

---

## üìñ Commands

### üîç `scan` - Discover Music Files

```bash
musicctl scan /path/to/music
```

Outputs a compact, parseable list of discovered music files:

```
/music/Artist/Album/track01.flac
/music/Artist/Album/track02.flac
```

### üå≥ `tree` - Visualize Library Structure

```bash
musicctl tree /path/to/music
```

Beautiful hierarchical view of your music library:

```
üìÅ Music Folder
‚îú‚îÄ‚îÄ üìÇ Tracks
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track1.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track2.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track3.flac [ü§ñ] FLAC
‚îú‚îÄ‚îÄ‚îÄ üéµ   Track4.flac [ü§ñ] FLAC
```

### üìñ `read` - Extract Metadata

```bash
# Read from FLAC file
musicctl read /Music/Tracks/Track1.flac

# Read from MP3 file  
musicctl read /Music/Tracks/Track1.mp3
```

Detailed metadata extraction:

```json
{
  "file_path": "/Music/Tracks/Track1.flac",
  "metadata": {
    "title": {
      "value": "Track1",
      "source": "Embedded",
      "confidence": 1.0
    },
    "artist": {
      "value": "Super Artist",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album": {
      "value": "Something",
      "source": "Embedded",
      "confidence": 1.0
    },
    "album_artist": {
      "value": "Album First",
      "source": "Embedded",
      "confidence": 1.0
    },
    "track_number": {
      "value": 9,
      "source": "Embedded",
      "confidence": 1.0
    },
    "disc_number": {
      "value": 1,
      "source": "Embedded",
      "confidence": 1.0
    },
    "year": {
      "value": 2025,
      "source": "Embedded",
      "confidence": 1.0
    },
    "genre": {
      "value": "New Age",
      "source": "Embedded",
      "confidence": 1.0
    },
    "duration": {
      "value": 205.871,
      "source": "Embedded",
      "confidence": 1.0
    },
     "format": "flac",
     "path": "/Music/Tracks/Track1.flac"
  }
}
```

### üî§ `normalize` - Fix Track Titles

```bash
# Preview changes
musicctl normalize /path/to/music --dry-run

# Apply changes
musicctl normalize /path/to/music
```

Transforms messy titles into clean title case:
- `"come together"` ‚Üí `"Come Together"`
- `"SOMETHING"` ‚Üí `"Something"`
- `"here comes the sun"` ‚Üí `"Here Comes The Sun"`

### üéµ `normalize-genres` - Normalize Music Genres

```bash
# Preview genre changes
musicctl normalize-genres /path/to/music --dry-run

# Apply changes
musicctl normalize-genres /path/to/music
```

Normalizes genres to standard categories:
- `"rock and roll"` ‚Üí `"Rock"`
- `"hip hop"` ‚Üí `"Hip-Hop"`
- `"electronic"` ‚Üí `"Electronic"`
- `"smooth jazz"` ‚Üí `"Jazz"`
- Supports 40+ standard genres and common aliases
- Handles slash-separated multiple genres

### ‚úèÔ∏è `write` - Update Metadata

```bash
# Preview metadata changes (FLAC or MP3)
musicctl write /path/to/track.flac --dry-run --set "title=New Title" --set "artist=New Artist"
musicctl write /path/to/track.mp3 --dry-run --set "title=New Title" --set "artist=New Artist"

# Apply metadata changes
musicctl write /path/to/track.flac --apply --set "title=New Title" --set "artist=New Artist"
musicctl write /path/to/track.mp3 --apply --set "title=New Title" --set "artist=New Artist"
```

Update embedded metadata in FLAC and MP3 files:

**Supported Metadata Fields:**
- `title` - Track title
- `artist` - Track artist
- `album` - Album name
- `albumartist` - Album artist
- `tracknumber` - Track number (1-99)
- `discnumber` - Disc number (1-99)
- `year` - Release year (1000-9999)
- `genre` - Genre name

**Examples:**
```bash
# Single field update (FLAC or MP3)
musicctl write track.flac --apply --set "title=Come Together"
musicctl write track.mp3 --apply --set "title=Come Together"

# Multiple field updates
musicctl write track.flac --apply --set "title=Come Together" --set "artist=The Beatles" --set "tracknumber=1"
musicctl write track.mp3 --apply --set "title=Come Together" --set "artist=The Beatles" --set "tracknumber=1"

# Dry run to preview changes
musicctl write track.flac --dry-run --set "year=1969"
musicctl write track.mp3 --dry-run --set "year=1969"
```

### ‚úÖ `validate` - Check Metadata Completeness

```bash
# Validate directory for missing required fields and inconsistencies
musicctl validate /path/to/music

# Validate with JSON output for automation
musicctl validate /path/to/music --json
```

**Validation Features:**
- **Required Fields**: Checks for title, artist, album
- **Recommended Fields**: Warns about missing track_number, year
- **Data Quality**: Flags unusual years, track numbers, very long titles
- **Multiple Formats**: Human-readable or structured JSON output

**Examples:**
```bash
# Check for missing metadata
musicctl validate ~/Music/

# JSON output for automation
musicctl validate ~/Music/ --json
```

**Output Examples:**

*Human-readable:*
```md
=== METADATA VALIDATION RESULTS ===
üìä Summary:
  Total files: 5
  Valid files: 3
  Files with errors: 2
  Files with warnings: 1

‚ùå Validation failed with 2 errors

üî¥ ERRORS:
  File: /music/track1.flac
  Field: artist
  Issue: Missing required field: artist

üü° WARNINGS:
  File: /music/track2.flac
  Field: year
  Issue: Year 1800 seems unusual (expected 1900-2100)
```

*JSON:*
```json
{
  "valid": false,
  "errors": [
    {
      "file_path": "/music/track1.flac",
      "field": "artist",
      "message": "Missing required field: artist"
    }
  ],
  "warnings": [
    {
      "file_path": "/music/track2.flac",
      "field": "year", 
      "message": "Year 1800 seems unusual (expected 1900-2100)"
    }
  ],
  "summary": {
    "total_files": 5,
    "valid_files": 3,
    "files_with_errors": 2,
    "files_with_warnings": 1
  }
}
```

### üîç `duplicates` - Find Duplicate Tracks

```bash
# Find duplicate tracks by checksum
musicctl duplicates /path/to/music

# JSON output for automation
musicctl duplicates /path/to/music --json
```

**Duplicate Detection Features:**
- **SHA256 Checksums**: Identifies identical files regardless of filename
- **Cross-Directory Detection**: Finds duplicates across different folders
- **Multiple Formats**: Human-readable group view or structured JSON output

**Examples:**
```bash
# Scan for duplicates in your library
musicctl duplicates ~/Music/

# JSON output for automation
musicctl duplicates ~/Music/ --json
```

**Output Examples:**

*Human-readable:*
```
Found 1 duplicate groups:

Duplicate Group 1 (3 files):
  /music/Artist/Album/track1.flac
  /music/Artist/Album/track2.flac
  /music/Compilations/track_copy.flac
```

*JSON:*
```json
[
  [
    {
      "file_path": "/music/Artist/Album/track1.flac",
      "metadata": { /* full track metadata */ },
      "checksum": "ae8850161fcc2cbda1d34e22d6813a75785128ca4c7d8df0ea05f89a16b53e22"
    },
    {
      "file_path": "/music/Artist/Album/track2.flac",
      "metadata": { /* full track metadata */ },
      "checksum": "ae8850161fcc2cbda1d34e22d6813a75785128ca4c7d8df0ea05f89a16b53e22"
    },
    {
      "file_path": "/music/Compilations/track_copy.flac",
      "metadata": { /* full track metadata */ },
      "checksum": "ae8850161fcc2cbda1d34e22d6813a75785128ca4c7d8df0ea05f89a16b53e22"
    }
  ]
]
```

**Use Cases:**
- **Library Cleanup**: Remove redundant copies to save disk space
- **Organization**: Identify duplicate tracks for playlist management
- **Quality Control**: Ensure only the best quality versions remain
- **Migration Planning**: Avoid importing duplicates when consolidating libraries

### üíø `cue` - Generate, Parse, or Validate CUE Files

```bash
# Generate CUE file for an album (dry run - preview only)
musicctl cue --generate /path/to/album --dry-run

# Generate and write CUE file
musicctl cue --generate /path/to/album

# Parse and display CUE file contents
musicctl cue --parse /path/to/album.cue

# Validate CUE file against audio files
musicctl cue --validate /path/to/album.cue

# Validate with custom audio directory
musicctl cue --validate /path/to/album.cue --audio-dir /path/to/audio
```

**CUE Operations:**

| Operation | Flag | Description |
|-----------|------|-------------|
| Generate | `--generate` | Create CUE file from album directory |
| Parse | `--parse` | Display parsed CUE file contents |
| Validate | `--validate` | Check CUE file against audio files |

**Generate Options:**
- `--output` - Specify output path for CUE file
- `--dry-run` - Preview without writing
- `--force` - Overwrite existing file

**Parse/Validate Options:**
- `--json` - JSON output for automation
- `--audio-dir` - Custom audio directory (validate only)

**CUE Generation Features:**
- Extracts metadata from FLAC, MP3, and WAV files
- Generates standard CUE sheets compatible with most audio players
- Supports multiple files per album (one FILE entry per track)
- Includes genre and year from track metadata
- Normalizes text to title case

**Output Example:**
```
PERFORMER "Kai Engel"
TITLE "Meanings"
REM GENRE New Age
REM DATE 2025
FILE "01. A New Journey Begins.flac" WAVE
  TRACK 01 AUDIO
    TITLE "A New Journey Begins"
    PERFORMER "Kai Engel"
    INDEX 01 00:00:00
FILE "02. Time Goes On.flac" WAVE
  TRACK 02 AUDIO
    TITLE "Time Goes On"
    PERFORMER "Kai Engel"
    INDEX 01 00:00:00
```

### üìñ `cue-parse` - Parse CUE Files

```bash
# Parse and display CUE file contents (human-readable)
musicctl cue-parse /path/to/album.cue

# Parse and output JSON for programmatic use
musicctl cue-parse /path/to/album.cue --json
```

**CUE Parsing Features:**
- Parses album-level metadata (performer, title, files)
- Parses track-level metadata (number, title, performer, index)
- Handles multi-file CUE sheets correctly
- JSON output for automation and AI agents

**Human-Readable Output:**
```
Cue File: /path/to/album.cue
  Performer: Kai Engel
  Title: Meanings
  Files:
    - 01. A New Journey Begins.flac
    - 02. Time Goes On.flac
  Tracks: 2
    Track 01: A New Journey Begins [01. A New Journey Begins.flac]
    Track 02: Time Goes On [02. Time Goes On.flac]
```

**JSON Output:**
```json
{
  "performer": "Kai Engel",
  "title": "Meanings",
  "genre": "Ambient",
  "date": "2024",
  "files": [
    "01. A New Journey Begins.flac",
    "02. Time Goes On.flac"
  ],
  "tracks": [
    {
      "number": 1,
      "title": "A New Journey Begins",
      "performer": "Kai Engel",
      "index": "00:00:00",
      "file": "01. A New Journey Begins.flac"
    }
  ]
}
```

### üîç `cue-validate` - Validate CUE Files

```bash
# Validate CUE file against audio files in same directory
musicctl cue-validate /path/to/album.cue

# Validate with custom audio directory
musicctl cue-validate /path/to/album.cue --audio-dir /path/to/audio

# JSON output for programmatic use
musicctl cue-validate /path/to/album.cue --json
```

**CUE Validation Features:**
- Checks that referenced audio files exist
- Validates track count consistency
- Supports custom audio directory
- Human-readable or JSON output

**Human-Readable Output:**
```
‚úì CUE file is valid
  All referenced files exist and track count matches.
```

**Validation Failed Output:**
```
‚úó CUE file validation failed:
  - Referenced audio file(s) missing
  - Track count mismatch between CUE and audio files
```

**JSON Output:**
```json
{
  "is_valid": false,
  "parsing_error": false,
  "file_missing": true,
  "track_count_mismatch": false
}
```

### üì§ `emit` - Export Structured Metadata

```bash
# AI-friendly structured text (default)
musicctl emit /path/to/music

# JSON format for programmatic use
musicctl emit /path/to/music --json
```

**Structured Text Output** (AI-optimized):
```
=== MUSIC LIBRARY METADATA ===
Total Artists: 1
Total Albums: 1
Total Tracks: 2

ARTIST: The Beatles
  ALBUM: Abbey Road (1969)
    TRACK: "Come Together" | Duration: 4:19 | File: /music/The Beatles/Abbey Road/01 - Come Together.flac
    TRACK: "Something" | Duration: 3:03 | File: /music/The Beatles/Abbey Road/02 - Something.flac

=== END METADATA ===
```

**JSON Output** (programmatic):
```json
{
  "artists": [
    {
      "name": "The Beatles",
      "albums": [
        {
          "title": "Abbey Road",
          "year": 1969,
          "tracks": [
            {
              "file_path": "/music/The Beatles/Abbey Road/01 - Come Together.flac",
              "metadata": {
                "title": { "value": "Come Together", "source": "Embedded", "confidence": 1.0 },
                "artist": { "value": "The Beatles", "source": "Embedded", "confidence": 1.0 },
                "album": { "value": "Abbey Road", "source": "Embedded", "confidence": 1.0 },
                "duration": { "value": 259.0, "source": "Embedded", "confidence": 1.0 }
              }
            }
          ]
        }
      ]
    }
  ],
  "total_tracks": 2,
  "total_artists": 1,
  "total_albums": 1
}
```

---

## üèóÔ∏è Architecture

music-chore follows **Unix philosophy principles**: small, sharp, composable tools.

```
src/
‚îú‚îÄ‚îÄ domain/                 # Pure business logic (no external deps)
‚îÇ   ‚îú‚îÄ‚îÄ models.rs           # Artist, Album, Track, Metadata
‚îÇ   ‚îú‚îÄ‚îÄ traits.rs           # AudioFile trait for extensibility
‚îÇ   ‚îî‚îÄ‚îÄ library.rs          # Library hierarchy building
‚îú‚îÄ‚îÄ infrastructure/         # External concerns
‚îÇ   ‚îú‚îÄ‚îÄ scanner.rs          # Format-agnostic directory scanning
‚îÇ   ‚îî‚îÄ‚îÄ formats/            # Audio format implementations
‚îÇ       ‚îú‚îÄ‚îÄ flac.rs          # FLAC format handler
‚îÇ       ‚îî‚îÄ‚îÄ mp3.rs           # MP3 format handler (ID3v2)
‚îî‚îÄ‚îÄ services/               # Business services
    ‚îú‚îÄ‚îÄ inference.rs        # Path-based metadata inference
    ‚îî‚îÄ‚îÄ normalization.rs    # Text normalization
```

### üéõÔ∏è Extensible Design

Adding new audio formats is simple (MP3 example already implemented):

```rust
impl AudioFile for Mp3Handler {
    fn can_handle(&self, path: &Path) -> bool {
        path.extension().map_or(false, |ext| ext == "mp3")
    }
    
    fn read_metadata(&self, path: &Path) -> Result<Track, AudioFileError> {
        // MP3-specific implementation
    }
}
```

---

## ü§ñ AI Agent Integration

### MCP Server (‚úÖ Complete)

music-chore includes a **fully functional Model Context Protocol (MCP) server** for seamless AI agent integration:

```bash
# Build and start MCP server
cargo install --path .
musicctl-mcp --verbose

# Test MCP server
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | musicctl-mcp
```

### üõ†Ô∏è Available MCP Tools

| Tool | Description | Parameters | Use Case |
|-------|-------------|------------|----------|
| `scan_directory` | Scan directories for music files | `path` (required), `json_output` (optional) | "Discover what music files I have" |
| `get_library_tree` | Get hierarchical library view | `path` (required), `json_output` (optional) | "Show me my library structure" |
| `read_file_metadata` | Read metadata from individual files | `file_path` (required) | "Extract full metadata from this track" |
| `normalize_titles` | Normalize track titles to title case | `path` (required), `dry_run` (optional) | "Fix messy capitalization in my tracks" |
| `emit_library_metadata` | Get complete structured library data | `path` (required), `json_output` (optional) | "Export my library for analysis" |
| `validate_library` | Validate metadata completeness | `path` (required), `json_output` (optional) | "Check my library for issues" |
| `find_duplicates` | Find duplicate tracks by checksum | `path` (required), `json_output` (optional) | "Find duplicate files in my library" |
| `generate_cue_file` | Generate CUE file for an album | `path` (required), `output` (optional), `dry_run` (optional), `force` (optional) | "Create CUE sheet for this album" |
| `parse_cue_file` | Parse and read CUE file contents | `path` (required) | "Read CUE file and extract metadata" |
| `validate_cue_file` | Validate CUE file against audio files | `path` (required), `audio_dir` (optional), `json_output` (optional) | "Check CUE file consistency" |

### üß™ Example AI Workflows

**Library Analysis:**
```
User: "Analyze my music library and tell me about my collection"
Claude: [Calls scan_directory ‚Üí get_library_tree ‚Üí emit_library_metadata]
"I found 15 artists across 42 albums with 380 total tracks. 
Your collection spans from 1968-2024 with genres including rock, jazz, and classical."
```

**Metadata Extraction:**
```
User: "What's the metadata for this Beatles track?"  
Claude: [Calls read_file_metadata]
"This FLAC file contains:
- Title: 'Come Together' (embedded, 100% confidence)
- Artist: 'The Beatles' (embedded, 100% confidence)  
- Album: 'Abbey Road' (embedded, 100% confidence)
- Duration: 4:19 (259 seconds)
- Format: FLAC, 16-bit/44.1kHz"

(Or for MP3 files):
"This MP3 file contains:
- Title: 'Come Together' (embedded, 100% confidence)
- Artist: 'The Beatles' (embedded, 100% confidence)  
- Album: 'Abbey Road' (embedded, 100% confidence)
- Duration: 4:19 (259 seconds)
- Format: MP3, ID3v2 tags"
```

**Batch Operations:**
```
User: "I just added 50 new tracks. Can you organize their titles?"
Claude: [Calls normalize_titles with dry_run=true ‚Üí normalize_titles with dry_run=false]
"Preview: 12 tracks need title corrections. Apply changes? [Yes/No]"
‚úÖ "Normalized 12 track titles: 'yesterday' ‚Üí 'Yesterday', 'come together' ‚Üí 'Come Together', etc."
```

### ‚úÖ Verify MCP Server Installation

Test that your MCP server is working:

```bash
cat <<EOF | musicctl-mcp | jq
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"bash","version":"0.1"}}}
{"jsonrpc":"2.0","method":"notifications/initialized"}
EOF
```

### AI-Friendly Features

- **Structured output**: Commands return parseable, machine-readable results
- **Composable operations**: Each command does one thing perfectly
- **Predictable behavior**: Same input always produces same output
- **Error handling**: Clear, structured error messages
- **Incremental processing**: Add new folders without full rescans

### Example Agent Workflow

```bash
# Discover what's new
musicctl scan ~/Music --since yesterday

# Get library overview  
musicctl tree ~/Music --json

# Export metadata for AI processing
musicctl emit ~/Music --json

# Extract specific metadata
musicctl read ~/Music/Artist/Album/track.flac

# Normalize new additions
musicctl normalize ~/Music --dry-run

# Update track metadata
musicctl write ~/Music/Artist/Album/track.flac --dry-run --set "title=New Title"

# Validate metadata completeness
musicctl validate ~/Music/
```

üìñ **Detailed MCP Documentation**: 
- [MCP Server Guide](docs/MCP_SERVER.md) - Complete server setup and usage
- [MCP Configuration Examples](docs/MCP_CONFIG_EXAMPLES.md) - Client integration examples

---

## üéØ Design Principles

1. **Local Only** - No internet access, no external services
2. **Format Agnostic** - Clean trait system for easy format extension  
3. **Deterministic** - Same input always produces same output
4. **CLI Native** - Designed for shell pipelines and automation
5. **AI Friendly** - Machine-readable output for agent usage
6. **Unix Philosophy** - Do one thing and do it exceptionally well

---

## üß™ Testing

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_emit_command
```

## ü§ù Contributing

1. **Fork** the repository
2. **Create** a feature branch: `git checkout -b feature/amazing-feature`
3. **Commit** your changes: `git commit -m 'Add amazing feature'`
4. **Push** to the branch: `git push origin feature/amazing-feature`
5. **Open** a Pull Request

### Development Guidelines

- Follow existing code patterns and conventions
- Add tests for all new functionality
- Keep modules small and focused
- Prefer clarity to cleverness
- All public functions must be tested

---

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

<div align="center">

**Built by AI Agent with ‚ù§Ô∏è for music lovers and AI agents**

*If you find this useful, give it a ‚≠ê on GitHub!*

</div>
